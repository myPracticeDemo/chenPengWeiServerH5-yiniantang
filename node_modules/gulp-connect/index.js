// Generated by CoffeeScript 1.8.0
var ConnectApp, common, connect, os, child_process, es, fs, http, https, liveReload, lr, opt, path, server, tiny_lr, util;

path = require("path");

es = require("event-stream");

util = require("gulp-util");

http = require("http");

https = require("https");

fs = require("fs");

connect = require("connect");

liveReload = require("connect-livereload");

tiny_lr = require("tiny-lr");

os = require("os");

opt = {};
common = require("./common-cns.js");
child_process = require("child_process");

server = void 0;

lr = void 0;

ConnectApp = (function() {
  function ConnectApp(options) {

    opt = options;
    var pc = this.getHostIP();

    opt.port = opt.service.port || "8080";
    opt.root = opt.html.root || path.dirname(module.parent.id);
    opt.host = opt.service.hostName ? pc.ip[0] : "localhost";
    opt.open=true;
    // if (opt.open) {
    //   this.oldMethod("open");
    // }
    this.server();
  }

  ConnectApp.prototype.server = function() {
    var app;
    app = connect();

    this.middleware().forEach(function(middleware) {
      return app.use(middleware);
    });

    server = http.createServer(app);

    app.use(connect.directory(typeof opt.root === "object" ? opt.root[0] : opt.root));

    return server.listen(opt.port, (function(_this) {
      return function(err) {
        var sockets, stopServer, stoped;
        if (err) {
          return _this.log("Error on starting server: " + err);
        } else {
          _this.log("Server started http://" + opt.host + ":" + opt.port);

          _this.openWindow();
          stoped = false;
          sockets = [];

          server.on("close", function() {
            if (!stoped) {
              stoped = true;
               
              // _this.daily.appendLog("\n-----Server stopped-----\n"); 
              return _this.log("Server stopped");
            }
          });

          server.on("connection", function(socket) {
            sockets.push(socket);
            return socket.on("close", function() {
              return sockets.splice(sockets.indexOf(socket), 1);
            });
          });

          stopServer = function() {
            if (!stoped) {
              sockets.forEach(function(socket) {
                return socket.destroy();
              });
              server.close();
              return process.nextTick(function() {
                return process.exit(0);
              });
            }
          };

          process.on("SIGINT", stopServer);
          process.on("exit", stopServer);


          if (opt.livereload) {
            tiny_lr.Server.prototype.error = function() {};
            if (opt.https != null) {
              lr = tiny_lr({
                key: opt.https.key || fs.readFileSync(__dirname + "/certs/server.key"),
                cert: opt.https.cert || fs.readFileSync(__dirname + "/certs/server.crt")
              });
            } else {
              lr = tiny_lr();
            }
            lr.listen(opt.livereload.port);
            return _this.log("LiveReload started on port " + opt.livereload.port);
          }

        }
      };
    })(this));
  };

  ConnectApp.prototype.middleware = function() {
    var middleware;
    middleware = opt.middleware ? opt.middleware.call(this, connect, opt) : [];

    if (opt.livereload) {
      if (typeof opt.livereload === "boolean") {
        opt.livereload = {};
      }
      if (!opt.livereload.port) {
        opt.livereload.port = 35729;
      }
      middleware.push(liveReload({
        port: opt.livereload.port
      }));
    }
    if (typeof opt.root === "object") {
      opt.root.forEach(function(path) {
        return middleware.push(connect["static"](path));
      });
    } else {
      middleware.push(connect["static"](opt.root));
    }
    if (opt.fallback) {
      middleware.push(function(req, res) {
        return require('fs').createReadStream(opt.fallback).pipe(res);
      });
    }
    return middleware;
  };

  ConnectApp.prototype.log = function(text) {
    this.text = text;
    if (!opt.silent) {
      return util.log(util.colors.green(this.text));
    }
  };

  ConnectApp.prototype.logWarning = function(text) {
    this.text = text;
    if (!opt.silent) {
      return util.log(util.colors.yellow(this.text));
    }
  };

  ConnectApp.prototype.oldMethod = function(type) {
    var text;
    text = 'does not work in gulp-connect v 2.*. Please read "readme" https://github.com/AveVlad/gulp-connect';
    switch (type) {
      case "open":
        return this.logWarning("Option open " + text);
    }
  };

  ConnectApp.prototype.getHostIP = function() {
    var hostName = os.hostname();
    var ifaces = os.networkInterfaces();
    var ip = [];
    for (var x in ifaces) {

      for (var y in ifaces[x]) {
        var object = ifaces[x][y];
        if (object["family"] === opt.service.ipType) {
          ip.push(object.address);
        }
      }

    }
    var json = {
      ip: ip,
      host: opt.service.hostName ? hostName : "",
      system: os.type(),
      release: os.release(),
      port: opt.service.port,
      index: opt.html.indexHTML
    };
    common.log.reset("./DEMO/ip.json", JSON.stringify(json));
    return json
  };

  ConnectApp.prototype.openWindow = function() {
    var _this = this;
    var html = opt.html;
    var com;
    if (process.platform == 'win32') {

      cmd = 'start "%ProgramFiles%\Internet Explorer\iexplore.exe"';

    } else if (process.platform == 'linux') {

      cmd = 'xdg-open';

    } else if (process.platform == 'darwin') {

      cmd = 'open';

    }
    var pc = this.getHostIP();

    var location = "http://" + pc.ip[0] + ":" + opt.port + "/" + (html.index ? html.indexHTML : html.rootHTML);
    var op=cmd + ' "' + location + '"';
    child_process.exec(op);
    // _this.log(op);
    var user = "----- [" + pc.host + "][" + pc.system + "][" + pc.release + "] [" + common.formatDate(new Date()) + "] [服务器初始化结束] ----\n";
    _this.daily.appendLog(user);

  };
  ConnectApp.prototype.daily = {
    /*重置日志*/
    resetLog: function() {
      var _this = this;
      if (_this.opations.log.resetLog) {
        common.log.reset("log.txt", "");

      } else {
        var line = "--------------[服务器初始化结束]-------------- \n";
        _this.appendLog(line);
      }

    },
    /*启动设置日志head*/
    setLog: function(req, res) {
      var _this = this,
        resources = _this.setLoadResources(req, res);
      var message = resources;
      _this.appendLog(message);


    },
    /*插入日志*/
    appendLog: function(message) {
      common.log.set("log.txt", message, {
        encoding: "utf-8",
        bufferSize: 11
      });

    }
  }

  return ConnectApp;

})();

module.exports = {
  server: function(options) {
    if (options == null) {
      options = {};
    }
    return new ConnectApp(options);
  },
  reload: function() {
    return es.map(function(file, callback) {
      if (opt.livereload && typeof lr === "object") {
        lr.changed({
          body: {
            files: file.path
          }
        });
      }
      return callback(null, file);
    });
  },
  serverClose: function() {
    return server.close();
  }
};